import logging

from .hanoi_exception import HanoiException
from .state import State
from .tower import Tower

logging.basicConfig(level = logging.INFO, format = '%(levelname)-10s  %(message)s')


class HanoiGame:
    """
    Main class for management of the data structures and moves of the game.
    """

    def __init__(self, n_discs, n_towers=3):
        """
        Initializes the game with n_discs and n_towers, which defaults to 3.
        At this step, the game can be solved and stored to consult.

        Raises a HanoiException if n_discs is negative or n_towers is less than 3.

        :param n_discs: Number of disks for this game.
        :param n_towers: Number of towers for this game. Default: 3
        """

        # Steps:
        # 1.- Check the parameters (Add the code after this comment)

        # 2.- Initialize the structure attributes (Add the code after this comment)

        # 3.- Initialize the towers (Add the code after this comment)

        # 4.- Solve and store the optimal solution

        if n_discs < 0:
            raise HanoiException("Number of disks must be positive")
        if n_towers < 3:
            raise HanoiException("Number of towers must be more or equal to 3")

        self.n_discs = n_discs
        self.towers = []

        self.n_towers = n_towers

        self.reset()
        self.moves = 0
        self.states = []
        self._solve()

    def reset(self):
        for i in range(self.n_towers):
            self.towers.append(Tower())
        for i in reversed(range(self.n_discs)):
            self.towers[0].push_disc(i + 1)

    def get_state(self, step):
        """
        Returns the state at the requested step in the optimal solution.
        Raises a HanoiException if the step index is negative or bigger than the total of states in the optimal
        solution.

        :param step: The step index in the optimal solution.
        :return: The state at the requested step in the optimal solution.
        """

        if step < 0 or step > len(self.states):
            raise HanoiException("Step index negative or bigger than the total of states in optimal solution")
        return self.states[step-1]

    def get_n_discs(self):
        """
        Returns the number of disks of this game.

        :return: The number of disks of this game.
        """
        return self.n_discs

    def get_n_towers(self):
        """
        Returns the number of towers of this game.

        :return: The number of towers of this game.
        """
        return self.n_towers

    def get_n_states(self):
        """
        Returns the number of states of the optimal solution. Ideally, it should be the size of the structure used to
        store the optimal solution states.

        :return: The number of states of the optimal solution.
        """
        return len(self.states)+1

    def move(self, source, target, move_id=None, depth=None):
        """
        Moves a disk from source tower to target tower.
        Raises a HanoiException if source and target are the same or if the move is invalid (the disk moved is bigger
        than the last disk in the target tower, the source tower is empty...)

        :param source: Tower from which a disk is going to be moved.
        :param target: Tower to which a disk is going to be moved.
        :param move_id: Identifier of the movement. Useful as information for the optimal state.
        :param depth: Depth of the recursion call. Useful as information for the optimal state.
        :return: The new state generated by the move.
        """

        if self.towers[source] == self.towers[target]:
            raise HanoiException("Source and target are the same tower. Invalid movement!")
        if not self.towers[target].is_empty() and self.towers[target].discs[-1] < self.towers[source].discs[-1]:
            raise HanoiException("The disk is bigger than the last disk in the target tower. Invalid movement!")
        if self.towers[source].is_empty():
            raise HanoiException("The source tower is empty. Invalid movement!")
        disc_to_move = self.towers[source].pop_disc()
        self.towers[target].push_disc(disc_to_move)

        if move_id != None:
            if len(self.states) == 0:
                move_id = 1
            else:
                move_id = self.states[-1].move_id + 1
            self.states.append(State(move_id, depth, disc_to_move, source+1, target+1, self.towers, self.n_discs))
            return self.states[-1]

    def _solve(self):
        """
        Generates and stores the optimal solution, reinitializing the towers afterwards.
        """

        self._solve_rec(self.n_discs, 0, 2, 1, 1)
        self.towers = []
        self.reset()


    def _solve_rec(self, n_discs, source, target, aux, depth):
        """
        Recursive call to solve the hanoi game optimally.

        :param n_discs: Number of disks to be moved.
        :param source: Tower from which a disk is going to be moved.
        :param target: Tower to which a disk is going to be moved.
        :param aux: Tower to be used as auxiliary.
        :param depth: Depth of the recursion call. Useful as information for the optimal state.
        """

        if n_discs > 0:
            self._solve_rec(n_discs - 1, source, aux, target, depth + 1)
            self.move(source, target, 0, depth)
            self._solve_rec(n_discs - 1, aux, target, source, depth + 1)

    def print_optimal_state(self, step):
        """
        Prints the optimal state at the selected step in the required format.

        :param step: Step index of the optimal solution.
        """
        print(self.states[step-1])

    def print_optimal_solution(self):
        """
        Prints all the states of the optimal solution in the required format.
        """
        for s in self.states:
            print(s)

    def is_finished(self):
        """
        Checks if the interactive game is finished, returns True if is finished, False otherwise.

        :return: True if the game is finished, False otherwise.
        """

        return True if len(self.towers[self.get_n_towers()-1].discs) == self.get_n_discs() else False

    def get_current_state(self):
        """
        Returns the current state of the game.

        :return: The current state of the game.
        """
        return State(None, None, None, None, None, self.towers, self.n_discs)

    def __repr__(self):
        """
        Returns a string with the internal representation of the game. This method can be used to represent the game
        information in a different format than the requested.

        :return: A string with the internal representation of the game.
        """
        raise NotImplementedError()

    def __str__(self):
        """
        Returns a string with the representation of the current state of the game in the requested format.

        :return: A string with the representation of the current state of the game in the requested format
        """
        return str(State(None, None, None, None, None, self.towers, self.n_discs))